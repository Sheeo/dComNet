\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[danish]{babel}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{listings}
\lstloadlanguages{C,sh,JVMIS}
\lstset{language=C}
\setlength{\parindent}{0in}
\setlength{\parskip}{0.1in}

\newcommand{\imul}{\texttt{imul}}

\newtheorem{theorem}{Sætning}

\title{Computere og Netværk (Q2/2010)}
\author{Mathias Rav, 20103940 \\
		Michael Søndergaard, 20104223 \\
		DAT-3}
\date{Uge 2, 14.\ november 2010}

\begin{document}
\maketitle

\section{Corrected version of \imul{} in C}

Følgende C-funktion \texttt{imul.c} kan udføre heltalsmultiplikation for både
negative og positive argumenter:

\begin{lstlisting}
int imul(int x, int y)
{ 
  int r; 
  int sign;
    
  sign = 1;
  if ( x < 0 ) {
    x = -x;
    sign = 0;
  }

  r = 0;
  while ( x > 0 ) {
    x = x - 1;
    r = r + y;
  }

  if ( sign == 0 ) r = -r;

  return r;
}
\end{lstlisting}

\section{Corrected \imul{} in IJVM}

En tilsvarende IJVM-metode ser således ud:

\lstset{language=JVMIS}
\begin{lstlisting}
.method imul     // int imul(int x, int y) {
.args 3
.locals 2
.define x = 1
.define y = 2
.define r = 3    // int r;
.define sign = 4 // int sign;

  bipush 0
  istore r       // r = 0;

  bipush 1
  istore sign    // sign = 0;

  iload x
  iflt THEN
  goto ENDIF

THEN:            // if (x < 0) {
  bipush 0
  iload x
  isub
  istore x       //   x = -x;

  bipush 0
  istore sign    //   sign = 0;

ENDIF:           // }
WHILE:
  iload x dup
  iflt ENDWHILE
  ifeq ENDWHILE  // while (x > 0) {

  iload x
  bipush 1
  isub
  istore x       //   --x;

  iload r
  iload y
  iadd
  istore r       //   r += y;

  goto WHILE     // }

ENDWHILE:
  iload sign
  ifeq THEN2
  goto ENDIF2    // if (sign == 0) {

THEN2:
  bipush 0
  iload r
  isub
  istore r       //   r = -r;

ENDIF2:          // }
  iload r
  ireturn        // return r;

.method main
.args 3
  bipush 120 // objref
  iload 1
  iload 2
  invokevirtual imul
  ireturn
\end{lstlisting}

Et hovedprogram med to argumenter er blevet udformet så \texttt{imul}-metoden
kan afprøves. Hovedprogrammet ser således ud:

\lstset{language=sh}
\begin{lstlisting}
#!/bin/sh
if ! [ -e gen ]; do mkdir gen; done
ijvm-asm imul.j|ijvm - $1 $2 > gen/trace
wc -l gen/trace
tail -1 gen/trace
\end{lstlisting}

\clearpage

Kørsler af hovedprogrammet med alle fire kombinationer af fortegn for argumenterne. Programmet gav

\lstset{language=sh}
\begin{lstlisting}
% sh ijvm.sh 4 4
16
% sh ijvm.sh -5 9
-45
% sh ijvm.sh 3 -8
-24
% sh ijvm.sh -6 -7
42
\end{lstlisting}

\section{Improved \texttt{idiv}}

C-funktionen idiv er blevet rettet og inkluderet i et C-program med henblik på afprøvning. (\texttt{./idiv/idiv.c})
Den er blevet afprøvet med alle kombinationer af fortegn for de to argumenter til C-funktionen.
Den rettede C-funktion ser således ud:

\lstset{language=C}
\begin{lstlisting}
int idiv(int x, int y) { 
	int q;
	q = 0;
	while ( x >= y ) {
		x = x - y;
		q = q + 1;
	}
	while ( x <= -y ) {
		x = x + y;
		q = q - 1;
	}
	return q;
}
\end{lstlisting}

En tilsvarende metode idiv er blevet udformet i IJVM. Den kom til at se sådan ud:

\lstset{language=sh}
\begin{lstlisting}

\end{lstlisting}


\end{document}
