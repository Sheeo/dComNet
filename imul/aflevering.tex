\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[danish]{babel}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{listings}

\setlength{\parindent}{0in}
\setlength{\parskip}{0.1in}

\newcommand{\imul}{\texttt{imul}}

\newtheorem{theorem}{Sætning}

\title{Computere og Netværk (Q2/2010)}
\author{Mathias Rav, 20103940 \\
		Michael Søndergaard, 20104223 \\
		DAT-3}
\date{Uge 1, 7.\ november 2010}

\begin{document}
\maketitle

\section{Multiplikation med \texttt{imul.c}}
Kørsel af programmet \texttt{imul.c} gav:

$\text{imul}(2,3) = 6$.

Ved kørsel med en negativ værdi for $x$ fås resultatet $0$.  $x$, den første
operand til \imul, indgår nemlig i while-løkkens betingelse: \texttt{while ( x
> 0 )}. Hvis $x$ ikke er positiv, så vil løkken ikke blive udført, og
resultatet af funktionen vil være $0$, selvom $xy\ne0$.

En kørsel med $x=2$ og $y=-4$ gav:

$\text{imul}(2,-4) = -8$.

Programmet vil altid multiplicere korrekt når $x$ er positiv, da
addition/subtraktion er defineret for alle heltal, sådan som det sker i
kodelinjen \texttt{p = p + y}.  Hvis $y$ er negativ, så vil $p$ blive mindre.

Rent matematisk har funktionen \imul{} en state, der er givet ved tuplen
$(x,y,p)$. Så længe $x>0$ vil kroppen af while-løkken ændre staten af
funktionen: $x$ bliver \'en mindre, og $y$ bliver lagt til $p$. Dette
fortsætter indtil $x$ er mindre end eller lig med $0$, hvor resultatet af
funktionen er $p$. Det kan beskrives ved en funktion såsom
\[\delta(x,y,p)=\left\{\begin{array}{cc}
	\delta(x-1,y,p+y) & \text{hvis }x>0 \\
	p & \text{hvis }x\leq 0
\end{array}\right.\]

\begin{theorem}
	For $x,y,p\in\mathbb{Z},x\leq0$ er $\delta(x,y,p)=xy+p$.
\end{theorem}

\begin{proof}
	Vi beviser sætningen ved induktion på $x$.
	\paragraph{Basis $x=0$} Ved definitionen af $\delta$ gælder netop $\delta(0,y,p)=p=0\cdot y+p$.
	\paragraph{Induktion} Antag, at $\delta(x-1,y,p)=(x-1)y+p$. Så er
	\begin{align*}
		\delta(x,y,p)&=\delta(x-1,y,p+y) \\
		&=(x-1)y+p+y \\
		&=xy+p. \qedhere{}
	\end{align*}
\end{proof}

Af induktionsbeviset fremgår det, at $\delta(x,y,p)=xy+p$. Da variablen $p$ er
lokal i funktionen og initialiseret til $0$, må resultatet ved kørsel af
C-funktionen $\texttt{imul(int x, int y)}$ for positiv $x$ og vilkårlig $y$
være $\delta(x,y,0)=xy$.
\clearpage
\section{Multiplikation med \imul{}-programmet, i IJVM}
En kørsel af programmet imul.j ser således ud:

IJVM Trace of gen/imul.bc Sun Nov  7 15:08:28 2010

\begin{tabular}{llllllllll}
                    &                    & stack = 0,& 1,& 16 \\
bipush 44           &\texttt{[10 2c]    }& stack = 44,& 0,& 1,& 16 \\
bipush 2            &\texttt{[10 02]    }& stack = 2,& 44,& 0,& 1,& 16 \\
bipush 3            &\texttt{[10 03]    }& stack = 3,& 2,& 44,& 0,& 1,& 16 \\
invokevirtual 0     &\texttt{[b6 00 00] }& stack = 15,& 51,& 0,& 3,& 2,& 22,& 0,& 1 \\
bipush 0            &\texttt{[10 00]    }& stack = 0,& 15,& 51,& 0,& 3,& 2,& 22,& 0 \\
istore 3            &\texttt{[36 03]    }& stack = 15,& 51,& 0,& 3,& 2,& 22,& 0,& 1 \\
iload 1             &\texttt{[15 01]    }& stack = 2,& 15,& 51,& 0,& 3,& 2,& 22,& 0 \\
iflt 25             &\texttt{[9b 00 19] }& stack = 15,& 51,& 0,& 3,& 2,& 22,& 0,& 1 \\
iload 1             &\texttt{[15 01]    }& stack = 2,& 15,& 51,& 0,& 3,& 2,& 22,& 0 \\
ifeq 20             &\texttt{[99 00 14] }& stack = 15,& 51,& 0,& 3,& 2,& 22,& 0,& 1 \\
iload 1             &\texttt{[15 01]    }& stack = 2,& 15,& 51,& 0,& 3,& 2,& 22,& 0 \\
bipush 1            &\texttt{[10 01]    }& stack = 1,& 2,& 15,& 51,& 0,& 3,& 2,& 22 \\
isub                &\texttt{[64]       }& stack = 1,& 15,& 51,& 0,& 3,& 2,& 22,& 0 \\
istore 1            &\texttt{[36 01]    }& stack = 15,& 51,& 0,& 3,& 1,& 22,& 0,& 1 \\
iload 3             &\texttt{[15 03]    }& stack = 0,& 15,& 51,& 0,& 3,& 1,& 22,& 0 \\
iload 2             &\texttt{[15 02]    }& stack = 3,& 0,& 15,& 51,& 0,& 3,& 1,& 22 \\
iadd                &\texttt{[60]       }& stack = 3,& 15,& 51,& 0,& 3,& 1,& 22,& 0 \\
istore 3            &\texttt{[36 03]    }& stack = 15,& 51,& 3,& 3,& 1,& 22,& 0,& 1 \\
goto -24            &\texttt{[a7 ff e8] }& stack = 15,& 51,& 3,& 3,& 1,& 22,& 0,& 1 \\
iload 1             &\texttt{[15 01]    }& stack = 1,& 15,& 51,& 3,& 3,& 1,& 22,& 0 \\
iflt 25             &\texttt{[9b 00 19] }& stack = 15,& 51,& 3,& 3,& 1,& 22,& 0,& 1 \\
iload 1             &\texttt{[15 01]    }& stack = 1,& 15,& 51,& 3,& 3,& 1,& 22,& 0 \\
ifeq 20             &\texttt{[99 00 14] }& stack = 15,& 51,& 3,& 3,& 1,& 22,& 0,& 1 \\
iload 1             &\texttt{[15 01]    }& stack = 1,& 15,& 51,& 3,& 3,& 1,& 22,& 0 \\
bipush 1            &\texttt{[10 01]    }& stack = 1,& 1,& 15,& 51,& 3,& 3,& 1,& 22 \\
isub                &\texttt{[64]       }& stack = 0,& 15,& 51,& 3,& 3,& 1,& 22,& 0 \\
istore 1            &\texttt{[36 01]    }& stack = 15,& 51,& 3,& 3,& 0,& 22,& 0,& 1 \\
iload 3             &\texttt{[15 03]    }& stack = 3,& 15,& 51,& 3,& 3,& 0,& 22,& 0 \\
iload 2             &\texttt{[15 02]    }& stack = 3,& 3,& 15,& 51,& 3,& 3,& 0,& 22 \\
iadd                &\texttt{[60]       }& stack = 6,& 15,& 51,& 3,& 3,& 0,& 22,& 0 \\
istore 3            &\texttt{[36 03]    }& stack = 15,& 51,& 6,& 3,& 0,& 22,& 0,& 1 \\
\end{tabular}
\clearpage
\begin{tabular}{llllllllll}
goto -24            &\texttt{[a7 ff e8] }& stack = 15,& 51,& 6,& 3,& 0,& 22,& 0,& 1 \\
iload 1             &\texttt{[15 01]    }& stack = 0,& 15,& 51,& 6,& 3,& 0,& 22,& 0 \\
iflt 25             &\texttt{[9b 00 19] }& stack = 15,& 51,& 6,& 3,& 0,& 22,& 0,& 1 \\
iload 1             &\texttt{[15 01]    }& stack = 0,& 15,& 51,& 6,& 3,& 0,& 22,& 0 \\
ifeq 20             &\texttt{[99 00 14] }& stack = 15,& 51,& 6,& 3,& 0,& 22,& 0,& 1 \\
iload 3             &\texttt{[15 03]    }& stack = 6,& 15,& 51,& 6,& 3,& 0,& 22,& 0 \\
ireturn             &\texttt{[ac]       }& stack = 6,& 0,& 1,& 16 \\
ireturn             &\texttt{[ac]       }& stack = 6
\end{tabular}

return value: 6

Stakkens maksimale størrelse er $11$.

Efter ordren \texttt{invokevirtual imul} ser stakken således ud:

$\text{stack} = 15, 51, 0, 3, 2, 22, 0, 1$

Når \texttt{invokevirtual imul} køres, ser maskinen, at \imul{} tager to
argumenter. Så popper den to argumenter samt en objektreference (som smides
væk) fra stakken og laver en ny stakbase med en link pointer, parameterliste,
lokal variabelliste samt den tidligere programtæller og link pointer-adresse.
Link pointeren, $22$, peger på hukommelsescellen der indeholder den tidligere
programtæller, som er $51$. Tæller vi nedad fra $22$ ved den tidligere
programtæller finder vi følgende adresser:

\begin{tabular}{|r|r|l|}
	\hline
	Adr. & Værdi & Forklaring \\
	\hline
	23 & 15 & tidligere LV \\
	22 & 51 & tidligere PC \\
	21 & 0 & lokal variabel \\
	20 & 3 & parameter \\
	19 & 2 & parameter \\
	18 & 22 & LV \\
	\hline
	17 & 0 & tidligere LV \\
	16 & 1 & tidligere PC \\
	15 & 16 & LV \\
	\hline
\end{tabular}

Hvorfor starter \texttt{main}s stak på adressen 15, og ikke på adressen 0?
Forklaringen her er, at de første 13 words (52 bytes) indeholder metodeområdet
og de næste 2 words indeholder programmets konstanter. Den tidligere
programtæller, 51, peger på den sidste instruktion i programmet, som
efterfølger kaldet til \texttt{invokevirtual} i \texttt{main}: \texttt{ac}
(\texttt{ireturn}).

Trace-outputtet ovenfor, viser kun de øverste 8 elementer af stakken. Dette er vildledende
da man ved optælling får den korrekte maksimale stack-størrelse, som er 11. Denne
størrelse optræder i while-løkken, når vi foretager binær aritmetik: Første
gang når vi skal udregne $x-1$, og anden gang når vi skal udregne $p+y$.

Stakkens maksimale størrelse er den samme uanset input. Det gør ingen forskel,
hvor mange gange kroppen af løkken udføres, da denne så at sige rydder op efter
sig selv, hvad angår stakken.

\subsection{Antal ordre udført}
Antallet af ordre udført er konstant med henhold til $y$. Der bliver ikke lavet
nogen sammenligninger, der involverer $y$ - den bliver bare lagt til en
midlertidig variabel. Derimod afhænger antallet af ordre udført af $x$.

For hver gang $x$ bliver en større, skal der udføres 13 instruktioner. Dette
svarer til det antal instruktioner, som findes i kroppen af while-løkken.
Derudover skal der udføres 14 instruktioner uden for løkken.
Antallet af instruktioner $i$ som funktion af parameteren $x$ kan derfor
skrives som

\[i(x)=\left\{\begin{array}{cc}
	13x + 14 & \text{hvis }x\geq0 \\
	14 & \text{hvis }x<0
\end{array}\right.\]


For at eftervise denne model laver vi en tabel over antallet af instruktioner
ved kørsel af \imul{} med forskellige parametre:

\begin{tabular}{|c|c|c|}
\hline
x & y & Instruktioner \\ \hline
0 & 2 & 14  \\ \hline
1 & 1 & 27  \\ \hline
2 & 3 & 40  \\ \hline
3 & 5 & 53  \\ \hline
4 & 4 & 66  \\ \hline
50& 1 & 664 \\ \hline

\end{tabular}

Disse data stemmer netop overens med vores model.

\subsection{Optimering af \imul{}}

For at mindske antallet af instruktioner, kan man TODO: optimér imul.

\end{document}
