\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[danish]{babel}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{listings}
\usepackage{color}
\lstloadlanguages{C,sh,JVMIS}
\setlength{\parindent}{0in}
\setlength{\parskip}{0.1in}

\newcommand{\ishl}{\texttt{ishl}}
\newcommand{\ishr}{\texttt{ishr}}
\newcommand{\iushr}{\texttt{iushr}}
\newcommand{\ijvm}{\textsc{ijvm}}
\newcommand{\ijvmmal}{\texttt{ijvm.mal}}
\newcommand{\ijvmspec}{\texttt{ijvm.spec}}

\newtheorem{theorem}{Sætning}

\lstset{ %
language=java,
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it's 1 each line 
                                % will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
tabsize=2,	          	        % sets default tabsize to 2 spaces
captionpos=b,                   % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
title=\lstname,                 % show the filename of files included with \lstinputlisting;
                                % also try caption instead of title
}


\title{Computers and Networks (Q2/2010)}
\author{Mathias Rav, 20103940 \\
		Michael Søndergaard, 20104223 \\
		DAT-3}
\date{Week 4, November 28, 2010}

\begin{document}
\maketitle

\section{Extension of \ijvmmal}
The microprogram that implements \ijvm{} has been changed to add the opcodes \ishl, \ishr{} and \iushr. We have added the following microcode to \ijvmmal:
\begin{lstlisting}
ishl = 0x78:         # ishl: a << b
	MAR = SP = SP - 1; rd
	OPC = 1 << 8       # 256
	OPC = OPC >> 1     # 128
	OPC = OPC >> 1     # 64
	OPC = OPC >> 1     # 32
	OPC = H = OPC - 1  # 31
	OPC = H AND TOS    # 0x3F & b
	H = MDR            # a
ishl_while:
	H = MDR = MDR + H  # a <<= 1
	OPC = OPC - 1; if (Z) goto ishl_endwhile; else goto ishl_while  # --b || break
ishl_endwhile:
	TOS = MDR; wr      # return a
	goto main

ishr = 0x7A:
	MAR = SP = SP - 1; rd
	OPC = 1 << 8       # 256
	OPC = OPC >> 1     # 128
	OPC = OPC >> 1     # 64
	OPC = OPC >> 1     # 32
	H = OPC - 1  # 31
	TOS = H AND TOS    # 0x3F & b
	N = MDR; if (N) goto ishr_signbit; else goto ishr_branch
ishr_branch:
	goto iushr_while
ishr_signbit:
	H = 1 << 8
	H = H >> 1
	H = H << 8
	H = H << 8
	H = H << 8
ishr_while:
	MDR = MDR >> 1
	MDR = MDR OR H # if the ALU does logical shift, add a sign bit to make this arithmetic
	TOS = TOS - 1; if (Z) goto ishr_endwhile; else goto ishr_while # --b || break
ishr_endwhile:
	TOS = MDR; wr	
	goto main

iushr = 0x7C:				# iushr: a >> b, logical
	MAR = SP = SP - 1; rd
	OPC = 1 << 8       # 256
	OPC = OPC >> 1     # 128
	OPC = OPC >> 1     # 64
	OPC = OPC >> 1     # 32
	H = OPC - 1  # 31
	TOS = H AND TOS    # 0x3F & b
iushr_signbit:
	OPC = 1 << 8
	OPC = OPC >> 1
	OPC = OPC << 8
	OPC = OPC << 8
	OPC = OPC << 8
	H = OPC - 1
iushr_while:
	MDR = MDR >> 1
	MDR = MDR AND H # if the ALU does arithmetic shift, remove the sign bit to make this logical
	TOS = TOS - 1; if (Z) goto iushr_endwhile; else goto iushr_while # --b || break
iushr_endwhile:
	TOS = MDR; wr	
	goto main
\end{lstlisting}
Unfortunately, \textsc{mic1} is unsure whether to do arithmetic or logical
right shift in the shifter. The file \texttt{Shifter.java} in the
Java-implementation of \textsc{mic1} endorsed by Tanenbaum computes the right
shift arithmetically and contains the following comment:
\begin{lstlisting}
if (value[MIR.SLL8])
	result = result << 8;
if (value[MIR.SRA1])
	result = result >> 1; // Issue: should shifter extend sign, as it does here?
\end{lstlisting}
Similarly, in the C-implementation used in this course, arithmetic shift is
enforced using the C code
\lstset{language=c}
\begin{lstlisting}
res = ~(~res >> 1);
\end{lstlisting}
\lstset{language=java}

However, for versatility, we have chosen to manipulate the sign bit manually in
both \ishr{} and \iushr. On \textsc{MIC1}-implementations using logical right
shift natively in the shifter, the bitmask generation and application in
\iushr{} may be removed, and vice versa in \ishr{} on a MIC1-implementation
using arithmetic right shift.

We have added the following to the specification file \ijvmspec:
\begin{lstlisting}
0x78 ishl
0x7A iushr
0x7C ishr
\end{lstlisting}
Finally, we have tested the opcodes using the following test program:
\begin{lstlisting}
.method main
.args 1
bipush 4
bipush 5
ishl      // 4 << 5 = 2^7 = 128
pop

bipush 120
bipush 3
iushr     // 120 >> 3 = 0b01111000 >> 3 = 0b0001111 = 15
pop
bipush -4
bipush 1
iushr
// logical (unsigned) shift: -4 >> 1 = 0b1111...1100 >> 1 = 0b0111...1110 = 2^32-2
pop
bipush -4
bipush 1
ishr
// arithmetic (signed) shift: -4 >> 1 = 0b1111...1100 >> 1 = 0b1111...1110 = -2
pop
bipush 5
bipush 2
ishr      // 5 >> 2 = 0b101 >> 2 = 0b001 = 1
ireturn
\end{lstlisting}
Compiling \ijvmmal{} using \texttt{mic1-asm} and running with \texttt{mic1}
yields the following trace:
\begin{lstlisting}
Mic1 Trace of ijvm.mic1 with test.bc Sun Nov 28 18:07:23 2010

                                stack = 0, 1, 11
bipush 4            [10 04]     stack = 4, 0, 1, 11
bipush 5            [10 05]     stack = 5, 4, 0, 1, 11
ishl                [78]        stack = 128, 0, 1, 11
pop                 [57]        stack = 0, 1, 11
bipush 120          [10 78]     stack = 120, 0, 1, 11
bipush 3            [10 03]     stack = 3, 120, 0, 1, 11
iushr               [7c]        stack = 15, 0, 1, 11
pop                 [57]        stack = 0, 1, 11
bipush -4           [10 fc]     stack = -4, 0, 1, 11
bipush 1            [10 01]     stack = 1, -4, 0, 1, 11
iushr               [7c]        stack = 2147483646, 0, 1, 11
pop                 [57]        stack = 0, 1, 11
bipush -4           [10 fc]     stack = -4, 0, 1, 11
bipush 1            [10 01]     stack = 1, -4, 0, 1, 11
ishr                [7a]        stack = -2, 0, 1, 11
pop                 [57]        stack = 0, 1, 11
bipush 5            [10 05]     stack = 5, 0, 1, 11
bipush 2            [10 02]     stack = 2, 5, 0, 1, 11
ishr                [7a]        stack = 1, 0, 1, 11
ireturn             [ac]        stack = 1
return value: 1
\end{lstlisting}
Notice the top of stack right after the calls to opcodes \ishl, \iushr{} and
\ishr: They are $128$, $15$, $2^{32}-2$, $-2$ and $1$ just as expected.
\end{document}
